# Коллоквиум по дискретной математике

Это лишь экспериментальная версия оболочки. В ней запросто могут найтись ошибки и недоработки. Обо всех проблемах, пожалуйста, сообщайте лично или через "Issues" на GitHub.

Для блоков N и Z реализованы все обёртки за исключением N-9 и N-10.

Для блоков Q и P структуры, функции и обёртки пока не готовы.

### Как добавить свой модуль?

В директории `modules` есть четыре каталога — по одному на каждый блок. Переходите в соответствующую папку и создаёте файл с именем формата `<номер_модуля_в_блоке>.h`. В нём должна быть функция с именем `<буква_блока><номер_модуля_в_блоке>`, причём буква блока именно прописная. Что эта функция принимает и что должна возвращать, можно подсмотреть в `interface/call/*.h`.

Чтобы включить добавленный модуль в проект, нужно раскомментировать соответствующую строчку в `config.h`. Для сборки достаточно скомпилировать `main.c`.

Доступные структуры и функции описаны в `template.h`. Пожалуйста, не пользуйтесь функциями выделения и освобождения памяти. Разрешено использовать небольшие массивы фиксированного размера.

И наконец, помните: ваш код — произведение искусства. Только от вас зависит, насколько приятно будет читать его другому человеку. Расставляйте отступы и пробелы, не делайте код слишком скученным, пишите комментарии. Почитайте [Linux kernel coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html).

### Как добавить наработки в основной репозиторий?

1. Сделать копию репозитория кнопкой `Fork` (наверху справа) или подтянуть изменения с помощью "Compare", если уже есть клон репозитория. Если не удаётся подтянуть изменения, можно удалить свою копию и сделать новый форк (не рекомендуется);

2. Внести необходимые изменения и сделать коммиты;

3. Сделать `Pull request`. При этом могут возникнуть конфликтные ситуации — тем не менее, не отклоняйте запрос. Будем смотреть и вносить соответствующие правки.

Перед тем, как делать пулл-запрос сюда, рекомендую потренироваться на [тестовом репозитории](https://github.com/kogutenko/test).

### ЧаВо

1. Что за тип `size_t`? Если вкратце — это беззнаковое целое, обычно имеющее длину 32 бита в 32-битных системах и 64 бита в 64-битных, соответственно. Предназначен для хранения размера массивов, счётчиков циклов и т.п. Подробнее можно узнать [тут](https://www.viva64.com/ru/t/0044/) и [здесь](https://ru.stackoverflow.com/questions/387641/%D0%A7%D1%82%D0%BE-%D0%B7%D0%B0-%D1%82%D0%B8%D0%BF-size-t).
